{"ts":1351776939025,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351776969889,"patch":[[{"diffs":[[1,"#!/usr/bin/node\n"]],"start1":0,"start2":0,"length1":0,"length2":16}]],"length":16,"saved":false}
{"ts":1351777049120,"patch":[[{"diffs":[[0,"in/node\n"],[1,"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\nvar Mustache;\n\n(function (exports) {\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = exports; // CommonJS\n  } else if (typeof define === \"function\") {\n    define(exports); // AMD\n  } else {\n    Mustache = exports; // <script>\n  }\n}((function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.0\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      return value.call(context.view, text, scopedRender) || \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Calculates the bounds of the section represented by the given `token` in\n   * the original template by drilling down into nested sections to find the\n   * last token that is part of that section. Returns an array of [start, end].\n   */\n  function sectionBounds(token) {\n    var start = token[3];\n    var end = start;\n\n    var tokens;\n    while ((tokens = token[4]) && tokens.length) {\n      token = tokens[tokens.length - 1];\n      end = token[3];\n    }\n\n    return [start, end];\n  }\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice.apply(template, sectionBounds(token));\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have a fifth item: an array that contains\n   * all tokens in that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case \"#\":\n      case \"^\":\n        token[4] = [];\n        sections.push(token);\n        collector.push(token);\n        collector = token[4];\n        break;\n      case \"/\":\n        if (sections.length === 0) {\n          throw new Error(\"Unopened section: \" + token[1]);\n        }\n\n        section = sections.pop();\n\n        if (section[1] !== token[1]) {\n          throw new Error(\"Unclosed section: \" + section[1]);\n        }\n\n        if (sections.length > 0) {\n          collector = sections[sections.length - 1][4];\n        } else {\n          collector = tree;\n        }\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    // Make sure there were no open sections when we're done.\n    section = sections.pop();\n\n    if (section) {\n      throw new Error(\"Unclosed section: \" + section[1]);\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var token, lastToken;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      if (lastToken && lastToken[0] === \"text\" && token[0] === \"text\") {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n        tokens.splice(i--, 1); // Remove this token from the array.\n      } else {\n        lastToken = token;\n      }\n    }\n  }\n\n  function escapeTags(tags) {\n    if (tags.length !== 2) {\n      throw new Error(\"Invalid tags: \" + tags.join(\" \"));\n    }\n\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    tags = tags || exports.tags;\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var tokens = [],      // Buffer to hold the tokens\n        spaces = [],      // Indices of whitespace tokens on the current line\n        hasTag = false,   // Is there a {{tag}} on the current line?\n        nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error(\"Unclosed tag at \" + scanner.pos);\n      }\n\n      tokens.push([type, value, start, scanner.pos]);\n\n      if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      }\n\n      // Set the tags for the next time around.\n      if (type === \"=\") {\n        tags = value.split(spaceRe);\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));"]],"start1":8,"start2":8,"length1":8,"length2":15513}]],"length":15521,"saved":false}
{"ts":1351777058402,"patch":[[{"diffs":[[0,") {\n"],[-1,"  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = exports; // CommonJS\n  } else if (typeof define === \"function\") {\n    define(exports); // AMD\n  } else {\n"],[0,"    "]],"start1":189,"start2":189,"length1":191,"length2":8},{"diffs":[[0,"script>\n"],[-1,"  }\n"],[0,"}((funct"]],"start1":221,"start2":221,"length1":20,"length2":16}]],"length":15334,"saved":false}
{"ts":1351777288076,"patch":[[{"diffs":[[0,"\n}())));"],[1,"\n\nMustache.render(\"{{t}}hi\", {\"t\": \"valuex\"});"]],"start1":15326,"start2":15326,"length1":8,"length2":54}]],"length":15380,"saved":false}
{"ts":1351777339409,"patch":[[{"diffs":[[0,"())));\n\n"],[1,"process.argv.forEach(function (val, index, array) {\n  console.log(index + ': ' + val);\n});\napp.listen(process.env.PORT, process.env.IP);\n\n"],[0,"Mustache"]],"start1":15328,"start2":15328,"length1":16,"length2":154}]],"length":15518,"saved":false}
{"ts":1351777349383,"patch":[[{"diffs":[[0,"});\n"],[-1,"app.listen(process.env.PORT, process.env.IP);"],[0,"\n\nMu"]],"start1":15423,"start2":15423,"length1":53,"length2":8}]],"length":15473,"saved":false}
{"ts":1351777354227,"patch":[[{"diffs":[[0,");\n});\n\n"],[-1,"\n"],[0,"Mustache"]],"start1":15420,"start2":15420,"length1":17,"length2":16}]],"length":15472,"saved":false}
{"ts":1351777436250,"patch":[[{"diffs":[[0,"rray) {\n"],[-1,"  "],[1,"if(i !== val) {\n"],[0,"console."]],"start1":15380,"start2":15380,"length1":18,"length2":32},{"diffs":[[0,"+ val);\n"],[1,"}\n"],[0,"});\n\nMus"]],"start1":15429,"start2":15429,"length1":16,"length2":18}]],"length":15488,"saved":false}
{"ts":1351777441850,"patch":[[{"diffs":[[0,"rray) {\n"],[1,"    "],[0,"if(i !=="]],"start1":15380,"start2":15380,"length1":16,"length2":20},{"diffs":[[0," val) {\n"],[1,"        "],[0,"console."]],"start1":15400,"start2":15400,"length1":16,"length2":24},{"diffs":[[0,"+ val);\n"],[1,"    "],[0,"}\n});\n\nM"]],"start1":15441,"start2":15441,"length1":16,"length2":20}]],"length":15504,"saved":false}
{"ts":1351777481148,"patch":[[{"diffs":[[0," if(i !="],[-1,"= val"],[1," 0 || i != 1"],[0,") {\n    "]],"start1":15391,"start2":15391,"length1":21,"length2":28}]],"length":15511,"saved":false}
{"ts":1351777493474,"patch":[[{"diffs":[[0," (val, i"],[-1,"ndex"],[0,", array)"]],"start1":15365,"start2":15365,"length1":20,"length2":16}]],"length":15507,"saved":false}
{"ts":1351777505838,"patch":[[{"diffs":[[0,"le.log(i"],[-1,"ndex"],[0," + ': ' "]],"start1":15424,"start2":15424,"length1":20,"length2":16}]],"length":15503,"saved":false}
{"ts":1351777522735,"patch":[[{"diffs":[[0,"\n    if("],[1,"!("],[0,"i "],[-1,"!"],[1,"="],[0,"= 0 || i"]],"start1":15383,"start2":15383,"length1":19,"length2":21},{"diffs":[[0,"| i "],[-1,"!"],[1,"="],[0,"= 1)"],[1,")"],[0," {\n "]],"start1":15401,"start2":15401,"length1":13,"length2":14}]],"length":15506,"saved":false}
{"ts":1351777562307,"patch":[[{"diffs":[[0," i == 1)) {\n"],[1,"\n"],[0,"        cons"]],"start1":15402,"start2":15402,"length1":24,"length2":25}]],"length":15507,"saved":false}
{"ts":1351777588302,"patch":[[{"diffs":[[0,"= 1)) {\n"],[1,"        if((function (filename) { //sneaky inline function for file extension finding\n                    var i = filename.lastIndexOf('.');\n                    return (i < 0) ? '' : filename.substr(i+1);\n                }(val)))"],[0,"\n       "]],"start1":15406,"start2":15406,"length1":16,"length2":245}]],"length":15736,"saved":false}
{"ts":1351777619824,"patch":[[{"diffs":[[0,"            "],[-1,"        "],[0,"var i = file"]],"start1":15500,"start2":15500,"length1":32,"length2":24},{"diffs":[[0,"f('.');\n"],[-1,"        "],[0,"        "]],"start1":15539,"start2":15539,"length1":24,"length2":16},{"diffs":[[0,"    "],[-1,"        }(val)))"],[1,"}(val))==\"js\") {"],[0,"\n   "]],"start1":15607,"start2":15607,"length1":24,"length2":24}]],"length":15720,"saved":false}
{"ts":1351777625088,"patch":[[{"diffs":[[0,"        "],[1,"    "],[0,"console."]],"start1":15628,"start2":15628,"length1":16,"length2":20},{"diffs":[[0,"+ val);\n"],[1,"        }\n"],[0,"    }\n})"]],"start1":15661,"start2":15661,"length1":16,"length2":26}]],"length":15734,"saved":false}
{"ts":1351777669738,"patch":[[{"diffs":[[0,"())));\n\n"],[1,"stache = {};\nstache.js = false;\n"],[0,"process."]],"start1":15328,"start2":15328,"length1":16,"length2":48}]],"length":15766,"saved":false}
{"ts":1351777679347,"patch":[[{"diffs":[[0,"))==\"js\") {\n"],[1,"            stache.js = val;\n"],[0,"            "]],"start1":15648,"start2":15648,"length1":24,"length2":53}]],"length":15795,"saved":false}
{"ts":1351777713267,"patch":[[{"diffs":[[0," false;\n"],[1,"stache. = false;\n"],[0,"process."]],"start1":15360,"start2":15360,"length1":16,"length2":33},{"diffs":[[0,"+ val);\n"],[1,"        } else {\n        \n"],[0,"        "]],"start1":15739,"start2":15739,"length1":16,"length2":42}]],"length":15838,"saved":false}
{"ts":1351777716330,"patch":[[{"diffs":[[0,"\nstache."],[1,"stache"],[0," = false"]],"start1":15367,"start2":15367,"length1":16,"length2":22}]],"length":15844,"saved":false}
{"ts":1351777727635,"patch":[[{"diffs":[[0,"\nstache."],[-1,"stache"],[1,"view"],[0," = false"]],"start1":15367,"start2":15367,"length1":22,"length2":20}]],"length":15842,"saved":false}
{"ts":1351777731963,"patch":[[{"diffs":[[0,".view = "],[-1,"false"],[1,"{}"],[0,";\nproces"]],"start1":15374,"start2":15374,"length1":21,"length2":18}]],"length":15839,"saved":false}
{"ts":1351777739502,"patch":[[{"diffs":[[0,"        "],[1,"    stache.view"],[0,"\n       "]],"start1":15765,"start2":15765,"length1":16,"length2":31}]],"length":15854,"saved":false}
{"ts":1351777748062,"patch":[[{"diffs":[[0,"che.view"],[1,"[val] = true;"],[0,"\n       "]],"start1":15780,"start2":15780,"length1":16,"length2":29}]],"length":15867,"saved":false}
{"ts":1351777767218,"patch":[[{"diffs":[[0,"al;\n"],[-1,"            console.log(i + ': ' + val);\n"],[0,"    "]],"start1":15703,"start2":15703,"length1":49,"length2":8}]],"length":15826,"saved":false}
{"ts":1351777806986,"patch":[[{"diffs":[[0,";\n        }\n"],[1,".length\n"],[0,"    }\n});\n\nM"]],"start1":15759,"start2":15759,"length1":24,"length2":32}]],"length":15834,"saved":false}
{"ts":1351777817722,"patch":[[{"diffs":[[0,"  }\n"],[1,"    }\n    if(process.argv"],[0,".length"],[-1,"\n    }"],[1,"=="],[0,"\n});"]],"start1":15767,"start2":15767,"length1":21,"length2":42}]],"length":15855,"saved":false}
{"ts":1351777836891,"patch":[[{"diffs":[[0,"v.length"],[-1,"=="],[0,"\n});\n\nMu"]],"start1":15795,"start2":15795,"length1":18,"length2":16}]],"length":15853,"saved":false}
{"ts":1351777848786,"patch":[[{"diffs":[[0,"\n    if("],[1,"i=="],[0,"process."]],"start1":15776,"start2":15776,"length1":16,"length2":19},{"diffs":[[0,"v.length"],[1,") {\n        console.log(val);\n    }"],[0,"\n});\n\nMu"]],"start1":15798,"start2":15798,"length1":16,"length2":51}]],"length":15891,"saved":false}
{"ts":1351777862876,"patch":[[{"diffs":[[0,".argv.length"],[1,"-1"],[0,") {\n        "]],"start1":15794,"start2":15794,"length1":24,"length2":26}]],"length":15893,"saved":false}
{"ts":1351778177034,"patch":[[{"diffs":[[0,"())));\n\n"],[1,"var fs = require('fs');\n"],[0,"stache ="]],"start1":15328,"start2":15328,"length1":16,"length2":40},{"diffs":[[0,"length-1) {\n"],[1,"    \n"],[0,"        cons"]],"start1":15824,"start2":15824,"length1":24,"length2":29}]],"length":15922,"saved":false}
{"ts":1351778196019,"patch":[[{"diffs":[[0,"('fs');\n"],[1,"var file = fs.readFileSync(path, \"utf8\");\nconsole.log(file);\n"],[0,"stache ="]],"start1":15352,"start2":15352,"length1":16,"length2":77}]],"length":15983,"saved":false}
{"ts":1351778203112,"patch":[[{"diffs":[[0,"');\n"],[-1,"var file = fs.readFileSync(path, \"utf8\");\nconsole.log(file);\n"],[0,"stac"]],"start1":15356,"start2":15356,"length1":69,"length2":8}]],"length":15922,"saved":false}
{"ts":1351778206130,"patch":[[{"diffs":[[0,") {\n    "],[1,"var file = fs.readFileSync(path, \"utf8\");\nconsole.log(file);"],[0,"\n       "]],"start1":15832,"start2":15832,"length1":16,"length2":76}]],"length":15982,"saved":false}
{"ts":1351778210834,"patch":[[{"diffs":[[0,"length-1) {\n"],[1,"    "],[0,"    var file"]],"start1":15824,"start2":15824,"length1":24,"length2":28},{"diffs":[[0,"utf8\");\n"],[1,"        "],[0,"console."]],"start1":15878,"start2":15878,"length1":16,"length2":24}]],"length":15994,"saved":false}
{"ts":1351778252842,"patch":[[{"diffs":[[0,"ync("],[-1,"path"],[1,"stache.js"],[0,", \"u"]],"start1":15867,"start2":15867,"length1":12,"length2":17}]],"length":15999,"saved":false}
{"ts":1351778257444,"patch":[[{"diffs":[[0,"e);\n"],[-1,"        console.log(val);\n"],[0,"    "]],"start1":15914,"start2":15914,"length1":34,"length2":8}]],"length":15973,"saved":false}
{"ts":1351778299820,"patch":[[{"diffs":[[0,"\");\n"],[-1,"        console.log(file);\n    }\n});\n\n"],[0,"Must"]],"start1":15887,"start2":15887,"length1":46,"length2":8},{"diffs":[[0,"luex\"});"],[1,"\n        console.log(file);\n    }\n});\n\n"]],"start1":15927,"start2":15927,"length1":8,"length2":47}]],"length":15974,"saved":false}
{"ts":1351778301824,"patch":[[{"diffs":[[0,"utf8\");\n"],[1,"        "],[0,"Mustache"]],"start1":15883,"start2":15883,"length1":16,"length2":24}]],"length":15982,"saved":false}
{"ts":1351778306190,"patch":[[{"diffs":[[0,"der("],[-1,"\"{{t}}hi\""],[1,"file"],[0,", {\""]],"start1":15911,"start2":15911,"length1":17,"length2":12}]],"length":15977,"saved":false}
{"ts":1351778309984,"patch":[[{"diffs":[[0,"});\n"],[-1,"        console.log(file);\n"],[0,"    "]],"start1":15935,"start2":15935,"length1":35,"length2":8}]],"length":15950,"saved":false}
{"ts":1351778324489,"patch":[[{"diffs":[[0,"le, "],[-1,"{\"t\": \"valuex\"}"],[1,"stache.view"],[0,");\n "]],"start1":15917,"start2":15917,"length1":23,"length2":19}]],"length":15946,"saved":false}
{"ts":1351778366408,"patch":[[{"diffs":[[0,"utf8\");\n"],[1,"        console.log(stache.view);\n"],[0,"        "]],"start1":15883,"start2":15883,"length1":16,"length2":50}]],"length":15980,"saved":false}
{"ts":1351778529411,"patch":[[{"diffs":[[0,"w);\n        "],[1,"console.log("],[0,"Mustache.ren"]],"start1":15921,"start2":15921,"length1":24,"length2":36},{"diffs":[[0,"stache.view)"],[1,")"],[0,";\n    }\n});\n"]],"start1":15967,"start2":15967,"length1":24,"length2":25}]],"length":15993,"saved":false}
{"ts":1351778673718,"patch":[[{"diffs":[[0,"\");\n"],[-1,"        console.log(stache.view);\n"],[0,"    "]],"start1":15887,"start2":15887,"length1":42,"length2":8}]],"length":15959,"saved":false}
{"ts":1351778809820,"patch":[[{"diffs":[[0,"    }\n    }\n"],[1,"    //if(val==\">\")\n"],[0,"    if(i==pr"]],"start1":15789,"start2":15789,"length1":24,"length2":43}]],"length":15978,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351785050278,"patch":[[{"diffs":[[0,"ode\n"],[-1,"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\nvar Mustache;\n\n(function (exports) {\n    Mustache = exports; // <script>\n}((function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.0\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      return value.call(context.view, text, scopedRender) || \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Calculates the bounds of the section represented by the given `token` in\n   * the original template by drilling down into nested sections to find the\n   * last token that is part of that section. Returns an array of [start, end].\n   */\n  function sectionBounds(token) {\n    var start = token[3];\n    var end = start;\n\n    var tokens;\n    while ((tokens = token[4]) && tokens.length) {\n      token = tokens[tokens.length - 1];\n      end = token[3];\n    }\n\n    return [start, end];\n  }\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice.apply(template, sectionBounds(token));\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have a fifth item: an array that contains\n   * all tokens in that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case \"#\":\n      case \"^\":\n        token[4] = [];\n        sections.push(token);\n        collector.push(token);\n        collector = token[4];\n        break;\n      case \"/\":\n        if (sections.length === 0) {\n          throw new Error(\"Unopened section: \" + token[1]);\n        }\n\n        section = sections.pop();\n\n        if (section[1] !== token[1]) {\n          throw new Error(\"Unclosed section: \" + section[1]);\n        }\n\n        if (sections.length > 0) {\n          collector = sections[sections.length - 1][4];\n        } else {\n          collector = tree;\n        }\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    // Make sure there were no open sections when we're done.\n    section = sections.pop();\n\n    if (section) {\n      throw new Error(\"Unclosed section: \" + section[1]);\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var token, lastToken;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      if (lastToken && lastToken[0] === \"text\" && token[0] === \"text\") {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n        tokens.splice(i--, 1); // Remove this token from the array.\n      } else {\n        lastToken = token;\n      }\n    }\n  }\n\n  function escapeTags(tags) {\n    if (tags.length !== 2) {\n      throw new Error(\"Invalid tags: \" + tags.join(\" \"));\n    }\n\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    tags = tags || exports.tags;\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var tokens = [],      // Buffer to hold the tokens\n        spaces = [],      // Indices of whitespace tokens on the current line\n        hasTag = false,   // Is there a {{tag}} on the current line?\n        nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error(\"Unclosed tag at \" + scanner.pos);\n      }\n\n      tokens.push([type, value, start, scanner.pos]);\n\n      if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      }\n\n      // Set the tags for the next time around.\n      if (type === \"=\") {\n        tags = value.split(spaceRe);\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));\n\nvar fs = require('fs');\nstache = {};\nstache.js = false;\nstache.view = {};\nprocess.argv.forEach(function (val, i, array) {\n    if(!(i == 0 || i == 1)) {\n        if((function (filename) { //sneaky inline function for file extension finding\n            var i = filename.lastIndexOf('.');\n            return (i < 0) ? '' : filename.substr(i+1);\n        }(val))==\"js\") {\n            stache.js = val;\n        } else {\n            stache.view[val] = true;\n        }\n    }\n    //if(val==\">\")\n    if(i==process.argv.length-1) {\n        var file = fs.readFileSync(stache.js, \"utf8\");\n        console.log(Mustache.render(file, stache.view));\n    }\n});\n\n"]],"start1":12,"start2":12,"length1":15966,"length2":4}]],"length":16,"saved":false}
{"ts":1351785060214,"patch":[[{"diffs":[[0,"in/node\n"],[1,"require('mustache-builder');"]],"start1":8,"start2":8,"length1":8,"length2":36}]],"length":44,"saved":false}
{"ts":1351785072118,"patch":[[{"diffs":[[0,"-builder"],[1,".js"],[0,"');"]],"start1":33,"start2":33,"length1":11,"length2":14}]],"length":47,"saved":false}
{"ts":1351785080670,"patch":[[{"diffs":[[0,"equire('"],[1,"./"],[0,"mustache"]],"start1":17,"start2":17,"length1":16,"length2":18}]],"length":49,"saved":false}
